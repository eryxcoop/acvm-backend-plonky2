{
  "noir_version": "0.31.0+bb3e128aad36b54a803dc1d4b3e0a2b23cd1d6a1",
  "hash": 5117046978248896655,
  "abi": {
    "parameters": [
      {
        "name": "hash_input",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 32,
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 8
        }
      },
      "visibility": "public"
    },
    "error_types": {}
  },
  "bytecode": "H4sIAAAAAAAA/72YeW8TPRDGJ0dL35ez3DflKJR7N2k2SUvb9L7v+0AoKQlCCP7h+0t46Bgcxx6vFYuVRs7E9vOz93G83mTg7Poh4id9zojI0ec+Jc9oeVbLc5T3UN8sdF55Kq9QGckrPiuMdVSbMdf9rs3a6kRtzl4XGYaot41lW3U+z6gcpPlzAn8GIm8Udh6AvzdukPJ/faNadMnqj5DuRuUd88x1Mpqy7hnDH2Q0044t6xgbx39uH3ehh/zqMFv5zsZ8zoxd1XsBHospLfhFinZDzE1Jyxlyj9moZVoEQynavXTcVFyE2OYxtF8u3VcG3Yoy/rQ6ryHdgnXpvLHqFLx03hp0knpUbSZJ2UfnnUGn0UjK9Wal5KPz3qBTPE2arWK54KMTGXTqpeFWq1Ss++jEBp1SHDVLhXLLR6dg0Kk2olJSqZz66BQNOnGrUvxcrTd8dIZN82o0o9PPcRX73oa/D6BXVL7+R+UbKt9S+Y7K91RGVMZUFqgsUjlMJS68RAQu5IqIqogREaMiPkDnScS1n32w10Xy4TcmYlzEhIgaicp9B+vUk9G4lk9oeY1y9XI9ZNUx6p6PddY1qUU8zvT7BOn2rJw2NpWBY5sw1p2Nu8bMieP7ejgKbg8nRUyJmBYxQ6LSk0lo92hKy6e1fAb8PRwFuxeTYPdwiulXhzAeToPdwxlmThzf18MRcHs4K2JOxLyIBRKVnsxCu0dzWj6v5Qvg7+EI2L2YBbuHc0y/Uwjj4TzYPVxg5sTxfT2sgtvDRRFLIpZFrJCo9GQR2j1a0vJlLV8Bfw+rYPdiEeweLjH9mhDGw2Wwe7jCzInj+3pYAbeHqyLWRKyL2CBR6ckqtHu0puXrWr4B/h5WwO7FKtg9XGP6fYEwHq6D3cMNZk4c39fDMrg93BSxJWJbxA6JSk82od2jLS3f1vId8PewDHYvNsHu4RbT7yuE8XAb7B7uMHPi+L4eJuD2cFfEnoh9EQckKj3ZhXaP9rR8X8sPwN/DBOxe7ILdwz2m3zcI4+E+2D08YObE8X09LIHbw0MRRyKORZyQqPTkENo9OtLyYy0/AX8PS2D34hDsHh4x/b5DGA+Pwe7hCTOntHzXH4h5Zo4ngRg9DOM4EKOXYRwFYpyDdOuoG0YfwzgIxPiPYewHYvzPMPYCMc5Dur25G8YFhrETiHGRYWwHYlxiGFuBGJch3XmnG8YVhrERiNHPMNYDMa4yjLVAjGuQ7h2iG8Z1hrESiHGDYSwHYtxkGEuBGLcg3Xt5N4zbDGMhEOMOw5gPxLjLMOYCMe4xjNlAjPsMYyYQ4wHDmA7EeMgwpgIxHjGMyUCMAYZRC8R4zDAmAjGeMIzxQIynDGOMYeC7mnwnyyu8DDFzyncDSjt8T8BzPJ6z8RyM51Q8R+I5D89heE7Cc4w8Z+BzGp+j+JzD5xA+J3Afx30W90Hcp3Afwd85/g7xd4Lr+BFx0Se8j0/BcFN6tVKtM7XXJ6p/ziptTfWm784bOP2G784Zxqrq4dWntK8Bv0CkQT0GVl6p71W0M27tWB1PDjrH2G8Y/y9S3Zou0yUAAA==",
  "debug_symbols": "3dvNSsNAFAXgd5l1F5k792cmryIisU0lUNLSpoKUvruJNqVi0YUgl7Oc5CzO2Uy+TU5h1T4fX566fr09hPrhFDbbZTN02348nQJ/PDrsmn46HYZmP4RaqkVo+1Wocz4vwrrbtKFmOy++BaOaXKJRS7mGU7kT5kiXLFO+jT4ugviooT5qmI8a2UeN4qNGrJz0iE56kJMeyUkPJ1dp/NtdSkXnHlSK/NzD0py1r5WnHuqkhznpkZ30KD56UOWkR3TSg5z0SE56sJMeTu5TcnKf0j/epzmnS7ZQ/CVq8yexVHyNEt371Mas86eWKN2Gp30ZfF/B3pcq8H0RfB+B70vg+xh8n4DvU/B94H5J4H5J4H5hcL8wuF8Y3C8M7hdm8H3gfmFwvzC4XxjcLwzuFwH3i4D7RcD9IuB+EQbfB+4XAfeLgPtFwP0i4H5RcL8ouF8U3C8K7hdl8H3gflFwvyi4XxTcLwruFwP3i4H7xcD9YuB+MQbfB+4XA/eLgfvFwP1i4H7J4H7J4H7J0H4ZD6/NvmueN+30//T07tgv59+px+Pwtvt8M2bfAQ==",
  "file_map": {
    "22": {
      "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n",
      "path": "std/field.nr"
    },
    "39": {
      "source": "// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n// SHA-256 hash function\npub fn digest<N>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N)\n}\n\nfn hash_final_block(msg_block: [u8; 64], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = crate::hash::sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes = (state[7 - j] as Field).to_le_bytes(4);\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n// Variable size SHA-256 hash\n#[no_predicates]\npub fn sha256_var<N>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let mut msg_block: [u8; 64] = [0; 64];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut i: u64 = 0; // Message byte pointer\n    for k in 0..N {\n        if k < message_size {\n            // Populate msg_block\n            msg_block[i] = msg[k];\n            i = i + 1;\n            if i == 64 {\n                // Enough to hash block\n                h = crate::hash::sha256_compression(msg_u8_to_u32(msg_block), h);\n\n                i = 0;\n            }\n        }\n    }\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[i] = 1 << 7;\n    i = i + 1;\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if i >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        if i < 64 {\n            for _i in 57..64 {\n                if i <= 63 {\n                    msg_block[i] = 0;\n                    i += 1;\n                }\n            }\n        }\n        h = crate::hash::sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        i = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes = (len as Field).to_le_bytes(8);\n    for _i in 0..64 {\n        // In any case, fill blocks up with zeros until the last 64 (i.e. until i = 56).\n        if i < 56 {\n            msg_block[i] = 0;\n            i = i + 1;\n        } else if i < 64 {\n            for j in 0..8 {\n                msg_block[63 - j] = len_bytes[j];\n            }\n            i += 8;\n        }\n    }\n    hash_final_block(msg_block, h)\n}\n",
      "path": "std/sha256.nr"
    },
    "47": {
      "source": "fn main(hash_input: [u8; 4]) -> pub [u8; 32]{\n    std::sha256::sha256_var(hash_input, 4)\n}",
      "path": "/home/bweisz/Documentos/proyectos/ethf-grants/plonky-2-backend-for-acir/noir_example/src/main.nr"
    }
  },
  "names": [
    "main"
  ]
}
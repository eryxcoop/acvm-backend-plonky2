{
  "noir_version": "0.31.0+bb3e128aad36b54a803dc1d4b3e0a2b23cd1d6a1",
  "hash": 14862116696656634331,
  "abi": {
    "parameters": [
      {
        "name": "hash_input",
        "type": {
          "kind": "array",
          "length": 4,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "public"
      }
    ],
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 32,
        "type": {
          "kind": "integer",
          "sign": "unsigned",
          "width": 8
        }
      },
      "visibility": "public"
    },
    "error_types": {}
  },
  "bytecode": "H4sIAAAAAAAA/72YaW8bNxCGR4cdt+kR90zPOE2cuDl3JWsl2bEt3/d9H0UhOVJRFM2X/H8gnHg24VLkcAkNssCAGpF8H3JfistVAW6uNyre0ueCihJ9HtHygpEXjbxE+RD1LUL/VabyDpVResU3hbWOagv2uve1RVedqi256yLLEM22cdpWn89DKsdp/pzAh4GkNwo7j8HHGzdO+ae+UT260uq/IN+NKnvmWepndNO6hwx/nNHMO7aiZ2wc/5F73JUh8qvPbO07F/MRM3Zd7zEELKa84Mc52k0wNyUvZ8I/ZquWbRFM5Gj3p+em4iLENvche/l0n1h0G9r48+o8hXwL1qfzzKlTCdJ5btFJ2lGzmyT1EJ0XFp1OJ6m3u41aiM5Li071Oun2qvVKiE5k0WnXJnu9WrUdohNbdGpx1K1V6r0QnYpFp9mJakmjcR2iU7XoxL1G9XWz3QnRmbTNq9ONrl/HTex7Fz4+gJ5Q+fQTlc+ofE7lCypfUhlRGVNZobJK5SSVuPASFbiQGyqaKqZUTKt4Bf0nEd9+9spdF6UPvxkVsyrmVLRINN13sE4/Gc0a+ZyRtyjXL99DVh+j6flMf12XWsSzTL+/Id+eVTLGpjNwbHPWuptxt5g5cfxQD6fB7+G8igUViyqWSDT1ZB6yHi0Y+aKRL0G4h9Pg9mIe3B4uMP3aIOPhIrg9XGLmxPFDPZwCv4fLKlZUrKpYI9HUk2XIerRi5KtGvgbhHk6B24tlcHu4wvS7BhkPV8Ht4RozJ44f6mET/B6uq9hQsalii0RTT9Yh69GGkW8a+RaEe9gEtxfr4PZwg+nXBRkPN8Ht4RYzJ44f6mED/B5uq9hRsatij0RTT7Yh69GOke8a+R6Ee9gAtxfb4PZwh+n3D8h4uAtuD/eYOXH8UA/r4PdwX8WBikMVRySaerIPWY8OjPzQyI8g3MM6uL3YB7eHB0y/f0HGw0Nwe3jEzInjh3qYgN/DYxUnKk5VnJFo6skxZD06MfJTIz+DcA8TcHtxDG4PT5h+/4GMh6fg9vCMmRPHD/WwBn4Pz1VcqLhUcUWiqSfnkPXowsgvjfwKwj2sgduLc3B7eMH0+x9kPLwEt4dXzJzy8n1/IJaZOV4JMYYYxqUQY5hhXAgxbkG+dTQIY4RhnAkxPmMYp0KMzxnGiRDjNuTbmwdhfMEwjoQYXzKMQyHGVwzjQIjxNeQ77wzCuMMw9oQYowxjV4jxDcPYEWJ8C/neIQZhfMcwtoQY3zOMTSHGDwxjQ4jxI+R7Lx+EcZdhrAkxfmIYq0KMnxnGihDjF4axLMT4lWEsCTF+YxiLQozfGcaCEOMew5gXYowxjJYQ4z7DmBNi/MEwZoUYDxjGDMPAd7UyZC89LxAb343GtHp8T8BzPJ6z8RyM51Q8R+I5D89heE7Cc0x6zsDnND5H8TmHzyF8TuA+jvss7oO4T+E+gr9z/B3i7wTX8T3iok94Hx/YbsqwUep1tvbmBM3PRa2trd723W0LZ9Ty3S3LWHU9vEa09i3gF0j60jpkYZW1+mFNu+DXjvXxlKB/jKOW8b8DNeEywtMlAAA=",
  "debug_symbols": "3dvNasJAFAXgd5m1i8yd+zOTVymlpBpLQKJoLBTx3Zu0RiyVdlEol7Mcc5BzNpNvk1NYtc/Hl6euX28PoX44hc122Qzdth9Pp8AfPx12TT+dDkOzH0ItvAhtvwp1ofMirLtNG2q28+JbMKrJJRq1lGs4lTthjnTJMuXb6OMiiI8a6qOG+aiRfdQoPmrEykmP6KQHOemRnPRwcpXGv92lVHTuQaXIzz0szVn7WnnqoU56mJMe2UmP4qMHVU56RCc9yEmP5KQHO+nh5D4lJ/cp/eN9mnO6/m38JWrzK7FUfI0S3XvVxqzzq5Yo3YanfRl8X8HelyrwfRF8H4HvS+D7GHyfgO9T8H3gfkngfkngfmFwvzC4XxjcLwzuF2bwfeB+YXC/MLhfGNwvDO4XAfeLgPtFwP0i4H4RBt8H7hcB94uA+0XA/SLgflFwvyi4XxTcLwruF2XwfeB+UXC/KLhfFNwvCu4XA/eLgfvFwP1i4H4xBt8H7hcD94uB+8XA/WLgfsngfsngfsnQfhkPr82+a5437fT99PTs2C/nz6nH4/C2+3wyZt8B",
  "file_map": {
    "22": {
      "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n",
      "path": "std/field.nr"
    },
    "39": {
      "source": "// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Convert 64-byte array to array of 16 u32s\nfn msg_u8_to_u32(msg: [u8; 64]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4*(i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n// SHA-256 hash function\npub fn digest<N>(msg: [u8; N]) -> [u8; 32] {\n    sha256_var(msg, N)\n}\n\nfn hash_final_block(msg_block: [u8; 64], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n\n    // Hash final padded block\n    state = crate::hash::sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes = (state[7 - j] as Field).to_le_bytes(4);\n        for k in 0..4 {\n            out_h[31 - 4*j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n// Variable size SHA-256 hash\n#[no_predicates]\npub fn sha256_var<N>(msg: [u8; N], message_size: u64) -> [u8; 32] {\n    let mut msg_block: [u8; 64] = [0; 64];\n    let mut h: [u32; 8] = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]; // Intermediate hash, starting with the canonical initial value\n    let mut i: u64 = 0; // Message byte pointer\n    for k in 0..N {\n        if k < message_size {\n            // Populate msg_block\n            msg_block[i] = msg[k];\n            i = i + 1;\n            if i == 64 {\n                // Enough to hash block\n                h = crate::hash::sha256_compression(msg_u8_to_u32(msg_block), h);\n\n                i = 0;\n            }\n        }\n    }\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[i] = 1 << 7;\n    i = i + 1;\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if i >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        if i < 64 {\n            for _i in 57..64 {\n                if i <= 63 {\n                    msg_block[i] = 0;\n                    i += 1;\n                }\n            }\n        }\n        h = crate::hash::sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        i = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes = (len as Field).to_le_bytes(8);\n    for _i in 0..64 {\n        // In any case, fill blocks up with zeros until the last 64 (i.e. until i = 56).\n        if i < 56 {\n            msg_block[i] = 0;\n            i = i + 1;\n        } else if i < 64 {\n            for j in 0..8 {\n                msg_block[63 - j] = len_bytes[j];\n            }\n            i += 8;\n        }\n    }\n    hash_final_block(msg_block, h)\n}\n",
      "path": "std/sha256.nr"
    },
    "47": {
      "source": "fn main(hash_input: pub [u8; 4]) -> pub [u8; 32]{\n    std::sha256::sha256_var(hash_input, 4)\n}",
      "path": "/home/bweisz/Documentos/proyectos/ethf-grants/plonky-2-backend-for-acir/noir_example/src/main.nr"
    }
  },
  "names": [
    "main"
  ]
}